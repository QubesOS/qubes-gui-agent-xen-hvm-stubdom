/* based on gui-agent/vmside.c */

#include <stdint.h>
#include "qemu/osdep.h"
#include "qemu-main.h"
#include "sysemu/sysemu.h"
#include "ui/console.h"
#include "ui/input.h"
#include "qemu/main-loop.h"

#include "qubes-gui-qemu.h"
#include <qubes-gui-protocol.h>
#include <xenctrl.h>
#include <xengnttab.h>
#include <libvchan.h>
#include "txrx.h"

/* from /usr/include/X11/X.h */
#define KeyPress               2
#define ButtonPress            4
#define Button1                 1
#define Button2                 2
#define Button3                 3
#define Button4                 4
#define Button5                 5
#define ShiftMask       (1<<0)
#define LockMask        (1<<1)
#define ControlMask     (1<<2)
#define Mod1Mask        (1<<3)
#define Mod2Mask        (1<<4)
#define Mod3Mask        (1<<5)
#define Mod4Mask        (1<<6)
#define Mod5Mask        (1<<7)


/* from /usr/include/X11/Xutil.h */
#define PPosition       (1L << 2) /* program specified position */
#define PSize           (1L << 3) /* program specified size */
#define PMinSize        (1L << 4) /* program specified minimum size */
#define PMaxSize        (1L << 5) /* program specified maximum size */
#define PResizeInc      (1L << 6) /* program specified resize increments */
#define PAspect         (1L << 7) /* program specified min and max aspect ratios */
#define PBaseSize       (1L << 8) /* program specified base for incrementing */
#define PWinGravity     (1L << 9) /* program specified window gravity */

// qubesgui_alloc_surface_data() has no ref to the gui state and is used before
// initializing the display so this needs to be global.
uint32_t qubesgui_domid = ~0;

typedef struct QubesGuiState {
    DisplayChangeListener dcl;
    DisplaySurface *surface;
    int log_level;
    libvchan_t *vchan;
    /* current message, keep here b/c  */
    struct msg_hdr hdr;
    /* amount of data to discard */
    int vchan_data_to_discard;

    char *clipboard_data;
    int clipboard_data_len;
    int x;
    int y;
    int mouse_x;
    int mouse_y;
    int init_done;
    int init_state;
    unsigned char local_keys[32];
    int led_state;
} QubesGuiState;

static void qubesgui_init_connection(QubesGuiState *qs);

#define QUBES_GUI_PROTOCOL_VERSION_STUBDOM (1 << 16 | 0)

// Autogenerated keycode -> scancode map
#include "qubes-keycode2scancode.c"

#define min(x,y) ((x)>(y)?(y):(x))
#define QUBES_MAIN_WINDOW 1

static void process_pv_update(QubesGuiState * qs,
                              int x, int y, int width, int height)
{
    struct msg_shmimage mx;
    struct msg_hdr hdr;

    hdr.type = MSG_SHMIMAGE;
    hdr.window = QUBES_MAIN_WINDOW;
    mx.x = x;
    mx.y = y;
    mx.width = width;
    mx.height = height;
    write_message(qs->vchan, hdr, mx);
}


static void qubes_create_window(QubesGuiState * qs, int w, int h)
{
    struct msg_hdr hdr;
    struct msg_create crt;

    // the following hopefully avoids missed damage events
    hdr.type = MSG_CREATE;
    hdr.window = QUBES_MAIN_WINDOW;
    crt.width = w;
    crt.height = h;
    crt.parent = 0;
    crt.x = 0;
    crt.y = 0;
    crt.override_redirect = 0;
    write_message(qs->vchan, hdr, crt);
}

static void send_pixmap_grant_refs(QubesGuiState * qs)
{
    size_t n;
    struct msg_hdr hdr;
    struct msg_window_dump_hdr wd_hdr;

    if (surface_xen_refs(qs->surface) == NULL) {
        fprintf(stderr, "Can't dump surface without grant refs allocation!\n");
        return;
    }

    n = ((surface_width(qs->surface) * surface_height(qs->surface) * 4) +
         XC_PAGE_SIZE - 1) >> XC_PAGE_SHIFT;

    hdr.type = MSG_WINDOW_DUMP;
    hdr.window = QUBES_MAIN_WINDOW;
    hdr.untrusted_len = MSG_WINDOW_DUMP_HDR_LEN + n * SIZEOF_GRANT_REF;

    wd_hdr.type = WINDOW_DUMP_TYPE_GRANT_REFS;
    wd_hdr.width = surface_width(qs->surface);
    wd_hdr.height = surface_height(qs->surface);
    wd_hdr.bpp = 24;

    write_struct(qs->vchan, hdr);
    write_struct(qs->vchan, wd_hdr);
    write_data(qs->vchan, (char *) surface_xen_refs(qs->surface),
               n * SIZEOF_GRANT_REF);
}

static void send_wmname(QubesGuiState * qs, const char *wmname)
{
    struct msg_hdr hdr;
    struct msg_wmname msg;
    strncpy(msg.data, wmname, sizeof(msg.data)-1);
    hdr.window = QUBES_MAIN_WINDOW;
    hdr.type = MSG_WMNAME;
    write_message(qs->vchan, hdr, msg);
}

static void send_wmhints(QubesGuiState * qs)
{
    struct msg_hdr hdr;
    struct msg_window_hints msg;

    // pass only some hints
    msg.flags = (PMinSize | PMaxSize);
    msg.min_width = surface_width(qs->surface);
    msg.min_height = surface_height(qs->surface);
    msg.max_width = surface_width(qs->surface);
    msg.max_height = surface_height(qs->surface);
    hdr.window = QUBES_MAIN_WINDOW;
    hdr.type = MSG_WINDOW_HINTS;
    write_message(qs->vchan, hdr, msg);
}

static void send_map(QubesGuiState * qs)
{
    struct msg_hdr hdr;
    struct msg_map_info map_info;

    map_info.override_redirect = 0;
    map_info.transient_for = 0;
    hdr.type = MSG_MAP;
    hdr.window = QUBES_MAIN_WINDOW;
    write_message(qs->vchan, hdr, map_info);
}

static void process_pv_resize(QubesGuiState * qs)
{
    if (!qs->surface) {
        return;
    }

    struct msg_hdr hdr;
    struct msg_configure conf;
    hdr.type = MSG_CONFIGURE;
    hdr.window = QUBES_MAIN_WINDOW;
    conf.x = qs->x;
    conf.y = qs->y;
    conf.width = surface_width(qs->surface);
    conf.height = surface_height(qs->surface);
    conf.override_redirect = 0;
    if (qs->log_level > 1)
        fprintf(stderr,
                "handle resize  w=%d h=%d\n", conf.width, conf.height);
    write_message(qs->vchan, hdr, conf);
    send_pixmap_grant_refs(qs);
    send_wmhints(qs);
}

static void handle_configure(QubesGuiState * qs)
{
    struct msg_configure r;
    read_data(qs->vchan, (char *) &r, sizeof(r));
    fprintf(stderr,
            "configure msg, x/y %d %d (was %d %d), w/h %d %d\n",
            r.x, r.y, qs->x, qs->y, r.width, r.height);

    qs->x = r.x;
    qs->y = r.y;
}

static int is_bitset(unsigned char *keys, int num)
{
    return (keys[num / 8] >> (num % 8)) & 1;
}

static void setbit(unsigned char *keys, int num, int value)
{
    if (value)
        keys[num / 8] |= 1 << (num % 8);
    else
        keys[num / 8] &= ~(1 << (num % 8));
}

static void send_keycode(QubesGuiState * qs, int keycode, int release)
{
    if (keycode > 255 || keycode < 0) {
        fprintf(stderr, "invalid keycode %d\n", keycode);
        return;
    }

    uint8_t scancode = qubes_keycode2scancode[keycode];

    setbit(qs->local_keys, keycode, !release);

    if (qs->log_level > 1)
        fprintf(stderr,
                "Received keycode %d(0x%x), converted to %d(0x%x)\n",
                keycode, keycode, scancode, scancode);
    if (!scancode) {
        fprintf(stderr, "Can't convert keycode %x to scancode\n",
                keycode);
        return;
    }

    qemu_input_event_send_key_number(qs->dcl.con, scancode, !release);
}

static void qubesgui_pv_kbd_led_event(void *opaque, int led_state) {
    QubesGuiState *qs = opaque;

    qs->led_state = led_state;
}

static void sync_kbd_state(QubesGuiState * qs, int kbd_state) {
    if ((!!(qs->led_state & QEMU_CAPS_LOCK_LED)) ^ (!!(kbd_state & LockMask))) {
        send_keycode(qs, 66, 0);
        send_keycode(qs, 66, 1);
    }
    if ((!!(qs->led_state & QEMU_NUM_LOCK_LED)) ^ (!!(kbd_state & Mod2Mask))) {
        send_keycode(qs, 77, 0);
        send_keycode(qs, 77, 1);
    }
}

static void handle_keypress(QubesGuiState * qs)
{
    struct msg_keypress key;

    read_data(qs->vchan, (char *) &key, sizeof(key));

    if (key.keycode != 66 && key.keycode != 77)
        sync_kbd_state(qs, key.state);
    send_keycode(qs, key.keycode, key.type != KeyPress);
}

static void handle_button(QubesGuiState * qs)
{
    struct msg_button key;
    int button = -1;

    read_data(qs->vchan, (char *) &key, sizeof(key));
    if (qs->log_level > 1)
        fprintf(stderr,
                "send buttonevent, type=%d button=%d\n",
                (int) key.type, key.button);

    if (key.button == Button1)
        button = INPUT_BUTTON_LEFT;
    else if (key.button == Button3)
        button = INPUT_BUTTON_RIGHT;
    else if (key.button == Button2)
        button = INPUT_BUTTON_MIDDLE;
    else if (key.button == Button4)
        button = INPUT_BUTTON_WHEEL_UP;
    else if (key.button == Button5)
        button = INPUT_BUTTON_WHEEL_DOWN;

    sync_kbd_state(qs, key.state);
    if (button != -1) {
        qemu_input_queue_btn(qs->dcl.con, button, key.type == ButtonPress);
        qemu_input_event_sync();
    } else {
        fprintf(stderr, "send buttonevent: unknown button %d\n",
                key.button);
    }
}

static void qubesgui_pv_mouse_set(DisplayChangeListener *dcl,
                                  int x, int y, int on) {
    QubesGuiState *qs = container_of(dcl, QubesGuiState, dcl);

    qs->mouse_x = x;
    qs->mouse_y = y;
}

static void handle_motion(QubesGuiState * qs)
{
    struct msg_motion key;
    int new_x, new_y, w, h;

    read_data(qs->vchan, (char *) &key, sizeof(key));
    new_x = key.x;
    new_y = key.y;

    w = surface_width(qs->surface);
    h = surface_height(qs->surface);

    if (new_x >= w)
        new_x = w - 1;
    if (new_y >= h)
        new_y = h - 1;

    if (qemu_input_is_absolute(qs->dcl.con)) {
        qemu_input_queue_abs(qs->dcl.con, INPUT_AXIS_X, new_x, 0, w - 1);
        qemu_input_queue_abs(qs->dcl.con, INPUT_AXIS_Y, new_y, 0, h - 1);
    } else {
        // Relative mode can't really work since dom0 don't grab the
        // mouse for this window. Therefore there will be always an
        // offset and some speed difference in relative mode. For the
        // case somebody really needs relative mode (for example
        // because of tablet driver problems) we speed the movement up
        // so that the real cursor can stay in the dom0 window while
        // moving on the virtual screen.

        qemu_input_queue_rel(qs->dcl.con, INPUT_AXIS_X,
                             (new_x - qs->mouse_x)*2);
        qemu_input_queue_rel(qs->dcl.con, INPUT_AXIS_Y,
                             (new_y - qs->mouse_y)*2);
    }

    qs->mouse_x = new_x;
    qs->mouse_y = new_y;

    qemu_input_event_sync();
}

static bool is_simple_modifier_key(int keycode) {
    switch (keycode) {
        case 50: // Shift_L
        case 62: // Shift_R
        case 37: // Control_L
        case 105: // Control_R
        case 133: // Super_L
        case 134: // Super_R
        case 64: // Alt_L
        case 108: // ISO_Level3_Shift (AltGr)
            return true;
        default:
            return false;
    }
}

static void handle_keymap_notify(QubesGuiState * qs)
{
    int i;
    unsigned char remote_keys[32];
    read_struct(qs->vchan, remote_keys);
    for (i = 0; i < 256; i++) {
        bool remote = is_bitset(remote_keys, i);
        bool local = is_bitset(qs->local_keys, i);
        if (remote != local && (!remote || is_simple_modifier_key(i))) {
            send_keycode(qs, i, !remote);
            if (qs->log_level > 1)
                fprintf(stderr,
                        "handle_keymap_notify: sending key %d %s\n",
                        i,
                        is_bitset(remote_keys, i) ? "down" : "up");
        }
    }
}

static void send_protocol_version(QubesGuiState *qs)
{
    uint32_t version = QUBES_GUI_PROTOCOL_VERSION_STUBDOM;
    write_struct(qs->vchan, version);
}


/* end of based on gui-agent/vmside.c */

static void qubesgui_pv_update(DisplayChangeListener * dcl, int x, int y, int w,
                               int h)
{
    QubesGuiState *qs = container_of(dcl, QubesGuiState, dcl);
    if (!qs->init_done)
        return;
    // ignore one-line updates, Windows send them constantly at no reason
    if (h == 1)
        return;
    process_pv_update(qs, x, y, w, h);
}

static void qubesgui_pv_switch(DisplayChangeListener * dcl, DisplaySurface * surface)
{
    QubesGuiState *qs = container_of(dcl, QubesGuiState, dcl);

    qs->surface = surface;

    if (!qs->init_done)
        return;

    process_pv_resize(qs);
}

static void qubesgui_pv_refresh(DisplayChangeListener * dcl)
{
    graphic_hw_update(dcl->con);
}

static bool qubesgui_pv_check_format(DisplayChangeListener *dcl,
                                     pixman_format_code_t format)
{
    return format == PIXMAN_x8r8g8b8;
}

static void qubesgui_message_handler(void *opaque)
{
    QubesGuiState *qs = opaque;
    char discard[256];


    libvchan_wait(qs->vchan);
    if (!qs->init_done) {
        qubesgui_init_connection(qs);
        return;
    }
    if (!libvchan_is_open(qs->vchan)) {
        qs->init_done = 0;
        qs->init_state = 0;
        qemu_set_fd_handler(libvchan_fd_for_select(qs->vchan),
                            NULL, NULL, NULL);
        libvchan_close(qs->vchan);
        /* FIXME: 0 here is hardcoded remote domain */
        qs->vchan = peer_server_init(0, 6000);
        qemu_set_fd_handler(libvchan_fd_for_select(qs->vchan),
                            qubesgui_message_handler, NULL, qs);
        fprintf(stderr,
                "qubes_gui: viewer disconnected, waiting for new connection\n");
        return;
    }

    // trigger write of queued data, if any present
    write_data(qs->vchan, NULL, 0);

    while (libvchan_data_ready(qs->vchan) > 0) {
        if (!qs->hdr.type) {
            int hdr_size;
            /* read the header if not already done */
            hdr_size = read_data(qs->vchan, (char *) &qs->hdr, sizeof(qs->hdr));
            if (hdr_size != sizeof(qs->hdr)) {
                fprintf(stderr,
                        "qubes_gui: got incomplete header (%d instead of %lu)\n",
                        hdr_size, sizeof(qs->hdr));
            }
        }

        if (qs->hdr.type && qs->vchan_data_to_discard < 0) {
            /* got header, check the data */

            /* fast path for not supported messages */
            switch (qs->hdr.type) {
                case MSG_KEYPRESS:
                case MSG_BUTTON:
                case MSG_MOTION:
                case MSG_KEYMAP_NOTIFY:
                case MSG_CONFIGURE:
                    /* supported - handled later */
                    break;
                default:
                    fprintf(stderr,
                            "qubes_gui: got unknown msg type %d, ignoring\n",
                            qs->hdr.type);
                    /* fallthrough */
                case MSG_CLIPBOARD_REQ:
                case MSG_CLIPBOARD_DATA:
                case MSG_MAP:
                case MSG_CLOSE:
                case MSG_CROSSING:
                case MSG_FOCUS:
                case MSG_EXECUTE:
                    qs->vchan_data_to_discard = qs->hdr.untrusted_len;
            }
        }

        if (qs->vchan_data_to_discard >= 0) {
            while (libvchan_data_ready(qs->vchan) && qs->vchan_data_to_discard) {
                qs->vchan_data_to_discard -= libvchan_read(qs->vchan, discard,
                        min(qs->vchan_data_to_discard, sizeof(discard)));
            }
            if (!qs->vchan_data_to_discard) {
                /* whole message "processed" */
                qs->hdr.type = 0;
                /* -1 to distinguish between "0 bytes to discard" and "do not
                 * discard this data" */
                qs->vchan_data_to_discard = -1;
            }
            continue;
        }

        /* WARNING: here is an assumption that every payload (of supported
         * message) will fit into vchan buffer; for now it is true, but once
         * this agent will start support for bigger messages, some local
         * buffering needs to be done */
        if (libvchan_data_ready(qs->vchan) < qs->hdr.untrusted_len) {
            /* wait for data */
            return;
        }

        switch (qs->hdr.type) {
        case MSG_KEYPRESS:
            handle_keypress(qs);
            break;
        case MSG_BUTTON:
            handle_button(qs);
            break;
        case MSG_MOTION:
            handle_motion(qs);
            break;
        case MSG_KEYMAP_NOTIFY:
            handle_keymap_notify(qs);
            break;
        case MSG_CONFIGURE:
            handle_configure(qs);
            break;
        default:
            fprintf(stderr,
                    "BUG: qubes_gui: "
                    "got unknown msg type %d, but not ignored earlier\n",
                    qs->hdr.type);
            exit(1);
        }
        qs->hdr.type = 0;
    }
}

static const DisplayChangeListenerOps dcl_ops = {
    .dpy_name = "qubes-gui",
    .dpy_gfx_update = qubesgui_pv_update,
    .dpy_gfx_switch = qubesgui_pv_switch,
    .dpy_gfx_check_format = qubesgui_pv_check_format,
    .dpy_refresh = qubesgui_pv_refresh,
    .dpy_mouse_set = qubesgui_pv_mouse_set
};

static void qubesgui_pv_display_init(DisplayState *ds, DisplayOptions *o)
{

    fprintf(stderr, "qubes_gui/init: %d\n", __LINE__);
    QubesGuiState *qs = g_new0(QubesGuiState, 1);
    if (!qs)
        return;

    qs->init_done = 0;
    qs->init_state = 0;
    qs->log_level = o->u.qubes_gui.log_level;

    fprintf(stderr, "qubes_gui/init: %d\n", __LINE__);
    qs->dcl.ops = &dcl_ops;
    fprintf(stderr, "qubes_gui/init: %d\n", __LINE__);
    // This also calls qubesgui_pv_switch() which sets the surface if
    // already available.
    register_displaychangelistener(&qs->dcl);

    qs->vchan = peer_server_init(qubesgui_domid, 6000);
    qemu_set_fd_handler(libvchan_fd_for_select(qs->vchan),
                        qubesgui_message_handler,
                        NULL,
                        qs);
    qubesgui_init_connection(qs);

    qemu_add_led_event_handler(qubesgui_pv_kbd_led_event, qs);
}

static void qubesgui_init_connection(QubesGuiState * qs)
{
    struct msg_xconf xconf;

    if (qs->init_state == 0) {
        qs->hdr.type = 0;
        /* -1 to distinguish between "0 bytes to discard" and "do not
         * discard this data" */
        qs->vchan_data_to_discard = -1;
        send_protocol_version(qs);
        fprintf(stderr,
                "qubes_gui/init[%d]: version sent, waiting for xorg conf\n",
                __LINE__);
        // XXX warning - thread unsafe
        qs->init_state++;
    }
    if (qs->init_state == 1) {
        if (!libvchan_data_ready(qs->vchan))
            return;

        read_struct(qs->vchan, xconf);
        fprintf(stderr,
                "qubes_gui/init[%d]: got xorg conf, creating window\n",
                __LINE__);
        // If we don't have a surface yet just send an arbitary window
        // size. QEMU should set a surface very soon.
        qubes_create_window(qs,
                            qs->surface ? surface_width(qs->surface) : 100,
                            qs->surface ? surface_height(qs->surface) : 100);

        send_map(qs);
        send_wmname(qs, qemu_get_vm_name());

        fprintf(stderr, "qubes_gui/init: %d\n", __LINE__);
        /* process_pv_resize will send grant refs */
        process_pv_resize(qs);

        qs->init_state++;
        qs->init_done = 1;
    }
}

static xengntshr_handle *xgs = NULL;

uint8_t *qubesgui_alloc_surface_data(int width, int height, uint32_t **refs) {
    size_t pages;
    uint8_t *data;

    if (qubesgui_domid == ~0) {
        fprintf(stderr, "GUI domain id not set before first surface allocation!\n");
        return NULL;
    }
   
    pages = ((width * height * 4) + XC_PAGE_SIZE - 1) >> XC_PAGE_SHIFT;

    *refs = calloc(pages, sizeof(uint32_t));
    if (*refs == NULL)
        return NULL;

    if (xgs == NULL) {
        xgs = xengntshr_open(NULL, 0);
        if (xgs == NULL) {
            fprintf(stderr, "Failed to open xengntshr!\n");
            return NULL;
        }
    }

    data = xengntshr_share_pages(xgs, qubesgui_domid, pages, *refs, 0);
    if (data == NULL) {
        fprintf(stderr, "Failes to allocate %zu grant pages!\n", pages);
        return NULL;
    }

    return data;
}

static void qubesgui_display_early_init(DisplayOptions *opts) {
    assert(opts->type == DISPLAY_TYPE_QUBES_GUI);
    qubesgui_domid = opts->u.qubes_gui.domid;
}

static QemuDisplay qemu_display_qubesgui = {
    .type   = DISPLAY_TYPE_QUBES_GUI,
    .init   = qubesgui_pv_display_init,
    .early_init = qubesgui_display_early_init,
};

static void register_qubesgui(void) {
    qemu_display_register(&qemu_display_qubesgui);
}

type_init(register_qubesgui);
